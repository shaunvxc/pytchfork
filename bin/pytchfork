#!/usr/bin/python
'''
For using pytchfork from the command line
'''
from multiprocessing import Process
import subprocess

import sys
from sys import stdout

def _pytchfork(target_command, target_args, num_procs):
    procs = _spawn_processes(target_command, target_args, num_procs)
    for proc in procs: proc.join()

def _spawn_processes(command, target_args, num_procs):
    procs = []
    for x in range(0, num_procs):
        p = Process(target=execute_command, args=(command, target_args))
        p.start()
        procs.append(p)
    return procs

def execute_command(command, target_args):
    target_command = [command]
    target_command.extend(target_args)
    subprocess.call(target_command)

def _print_usage():
    sys.stdout.write( "Usage: 1.`pytchfork target [num_procs] ` \n")
    sys.stdout.write( "       i.e.: pytchfork -p test.py 3 \n")
    sys.stdout.write( "    or 2.`pytchfork package target [num_procs] ` \n")
    sys.stdout.write( "       i.e.: pytchfork -p -m scraper.bin scrape_data 5 \n")

def parse_sys_args(args):

    if    args[1] == '-h': _print_usage(); exit()
    elif  args[1] == '-p': target_command = "python"
    else: target_command = args[1]

    if args[len(args) -1 ].isdigit():
        num_procs = args[len(args) -1]
        target_args = [ args[i] for i in range(2, len(args) -1)]
    else:
        num_procs = 2 # 2 processes by default
        target_args = [args[i] for i in range(2, len(args) )]

    return target_command, target_args, int(num_procs)

if __name__ == '__main__':
    target_command, target_args, num_procs = parse_sys_args(sys.argv)
    _pytchfork(target_command, target_args, num_procs)
