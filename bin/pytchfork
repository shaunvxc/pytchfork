#!/usr/bin/python
'''
For using pytchfork from the command line
'''
from multiprocessing import Process

import subprocess
import argparse

import sys
from sys import stdout

DEFAULT_NUM_PROCS = 2

def _pytchfork(target_command, target_args, num_procs):
    procs = _spawn_processes(target_command, target_args, num_procs)
    for proc in procs: proc.join()

def _spawn_processes(command, target_args, num_procs):
    procs = []
    for x in range(0, num_procs):
        p = Process(target=execute_command, args=(command, target_args))
        p.start()
        procs.append(p)
    return procs

def execute_command(command, target_args):
    target_command = [command]
    target_command.extend(target_args)
    subprocess.call(target_command)

def _print_usage():
    sys.stdout.write( "Usage: 1.`pytchfork target [num_procs] ` \n")
    sys.stdout.write( "       i.e.: pytchfork test.py 3 \n")
    sys.stdout.write( "    or 2.`pytchfork package target [num_procs] ` \n")
    sys.stdout.write( "       i.e.: pytchfork scraper.bin scrape_data 5 \n")

def parse_sys_args(args):

    target_command = args[1]

    if args[len(args) -1 ].isdigit():
        num_procs = args[len(args) -1]
        target_args = [ args[i] for i in range(2, len(args) -1)]
    else:
        num_procs = DEFAULT_NUM_PROCS
        target_args = [args[i] for i in range(2, len(args) )]

#    sys.stdout.write(str(target_command) + ' ' + str(target_args) + ' ' + str(num_procs) + '\n')
    return target_command, target_args, int(num_procs)

if __name__ == '__main__':
    target_command, target_args, num_procs = parse_sys_args(sys.argv)
    _pytchfork(target_command, target_args, num_procs)
